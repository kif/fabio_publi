\documentclass[preprint ]{iucr}
 \papertype{CP}
 \journalcode{J}


%
% This is needed for miktex on windows. From:
% http://huang-nao.blogspot.fr/2009/05/harvard-package-problems-in-miktex.html
%
\RequirePackage{hyperref}
\RequirePackage{harvard}
\renewcommand{\harvardurl}{URL:\url}


\begin{document}

\title{FabIO: easy access to 2D X-ray detector images in Python}
\shorttitle{FabIO}

    \author[a]{Henning O.}{S{\o}rensen}
    \author[b]{Erik B.}{Knudsen}
    \author[c]{Jonathan P.}{Wright}
	\author[c]{Ga\"el}{Goret}
	\cauthor[c]{J\'er\^ome}{Kieffer}{jerome.kieffer@esrf,fr}{}
% swapped JK & GG to prevent line-jump (cesure) 
    \aff[a]{Nano-Science Center, Department of Chemistry, University of Copenhagen,
            Universitetsparken 5, \city{Copenhagen}, \country{Denmark} }
    \aff[b]{Department of Physics, Technical University of Denmark,
            \city{Kongens Lyngby} \country{Denmark}}
    \aff[c]{European Synchrotron Radiation Facility, \city{Grenoble}, \country{France}}
	\shortauthor{S$\o$rensen et al.}

\maketitle

\section{Introduction}

One obstacle when writing software to analyse data collected from a
two-dimensional detector is to read the raw data into the program,
not least because the data can be stored in many different formats
depending on the instrument used.
To overcome this problem we decided to develop a general module,
FabIO (FABle I/O), to handle reading and writing of two-dimensional
data.
The code-base was initiated by merging parts of our fabian imageviewer
\cite{fabian} and ImageD11 \cite{ImageD11} peak-search programs and has
been developed since 2007 as part of the FABLE \cite{fable} program suite
for analysis of 3DXRD microscopy data \cite{3dxrd}.
During integration into a range of scientific programs like FitAllB
\cite{fitallb}, the FABLE graphical interface \cite{fable}, EDNA \cite{edna} and
the fast azimuthal integration library, pyFAI \cite{pyfai}; FabIO has gained
several features like handling multi-frame image formats as well as
writing many of the file formats.

We believe FabIO is now ready for a wider audience and could save other
researchers from repeating the work involved in decoding a
binary file format.The table \ref{format} shows the list of file formats that
FabIO can currently (ver. 0.1.0) read.


\section{FabIO Python module}

Python \cite{python} is a scripting language that is very popular among scientists
and which also allows well structured application and libraries to be developed.

\subsection{Philosophy}

The intention behind this development was to create a Python module which would
enable easy reading of 2D data images, from any detector; without having to
worry about the file format.
Therefore FabIO just needs a file name to open a file and it determines the
file format automatically and deals with gzip \cite{gzip} and bzip2
\cite{bzip2} compression transparently.
Opening a file returns an object which stores the image
{\em data} in memory as a 2D NumPy array \cite{numpy} and the metadata,
called {\em header}, in a python dictionary. Beside the
{\em data} and {\em header} properties, some methods are provided for reading
the {\em previous} or {\em next} image in a series of images as well as jumping
to a specific file number.
For the user, these auxiliary methods are intended to be independent of
the image format (as far as is reasonably possible).

FabIO is written in an object-oriented style (with classes) but aims at being
used in a scripting environment: special care has been taken to ensure the 
library remains easy to use. 
Therefore no knowledge of object-oriented programming is required to get 
full benefits of the library. 
As the development is done in a collaborative and decentralized way; a
comprehensive test suite has been added to reduce the number of regressions
when new features are added or old problems are repaired. 
The software is very modular and allows new classes to be added for handling 
other data formats quite easily.
FabIO and its source-code are freely available to everyone on-line \cite{fabio}, 
licensed under the GNU General Public License version 3 (GPLv3) and available
directly from popular Linux distribution like Debian and Ubuntu.

\subsection{Implementation}
The main language used in the development of FabIO is Python \cite{python};
however, some image formats are compressed and require
compression algorithms for reading and writing data. 
When such algorithms could not be implemented efficiently using Python or NumPy 
then native modules were developed, i.e. standard C code callable from Python 
(sometimes generated using Cython \cite{cython}).
This code has to be compiled for each computer architecture and offers 
excellent performance.
FabIO is dependent on the numpy module and has extra features if two other
optional python modules are available. 
For reading XML files (that are used in EDNA) the Lxml module is required 
and the Python Image Library, PIL \cite{pil} is needed for the display of 
images and several image-processing operations that are not re-implemented 
in FabIO.
A variety of useful image processing is also available in the scipy.ndimage 
module \cite{scipy}.
%FIXME is it now scikits??


Images can also be displayed in a convenient interactive manner using
matplotlib \cite{matplotlib} and an IPython shell \cite{ipython}, which is
mainly used for developing data analysis algorithms.
Reading and writing procedure of the various TIFF \cite{tiff} formats is based
on the TiFFIO code from PyMCA \cite{pymca}.

In the Python shell, the {\em fabio} module must be imported prior to reading an
image in one of the supported file formats (see Table \ref{format}).
The {\em fabio.open} function creates an instance of the Python class {\em fabioimage},
from the name of a file. This instance, named {\em img} hereafter, stores the
image data in {\em img.data} as a 2D NumPy array. Often the image file contains
more information than just the intensities of the pixels, e.g.
information about how the image is stored and the instrument parameters at the
time of the image acquisition, these metadata are usually stored in
the file header.
Header information, are available in {\em img.header} as a Python
dictionary where keys are strings and values are usually strings or
numeric values.

Currently, FabIO does not attempt to interpret or translate any metadata which
is found in the headers of various frame formats, but merely presents the
information as a string. Nevertheless FabIO is capable of converting one
image data-format into another by taking care of the numerical specificities: 
for example float arrays are converted to integer arrays if the output format only
accepts integers.


\subsection{FabIO methods}

% max/min should really be directly the numpy array methods on img.data
% This paragraph is repeated information from above. We can compress a bit 
% for overall length perhaps by moving that here or this there.


One the strengths of the implementation in an object oriented language
is the possibility to combine functions (or methods) together with data which
are appropriate for specific formats.
In addition to the header information and image data, every {\em fabioimage}
instance (returned by {\em fabio.open}) has methods inherited from fabioimage 
which provide information about the image minimum, maximum and mean values.
There are methods which gives the file number, name etc. One of the most
important methods which actually changes for certain formats  is get next image
in a sequence; these methods are {\em .next()}, {\em .previous()}, and {\em
.getframe(n)}. Of course the behaviour of such methods varies depending on the
image format: if it is single-framed (like mar345),  {\em .next()} will
return the image in next file. On multi-frame format (like GE), {\em .next()} will
return the next frame within the same file. For format wich are possibly multi-framed like
EDF, the behaviour depends on the actual number of frames per file (accessible
via the {\em .nframes} property).


\section{Installation}

As any Python module, FabIO can be installed from its sources available on 
sourceforge\cite{fabio}.
We generally advise users to try the packages provided for the most common
platforms on sourceforge: Windows, MacOSX and Linux. 
Moreover FabIO is part of
common Linux distributions Ubuntu (since 11.10) and Debian7 where the package is named
{\em python-fabio} and can be installed via {\em \# apt-get install python-fabio}.

\subsection{Examples}

Opening an image:

\begin{verbatim}
import fabio     
im0 = fabio.open('Quartz_0100.tif') # Open image file
print(im0.data[1024,1024]) # check a pixel value
im1 = im0.next() # Open next image
im270 = im1.getframe(270) # Jump to file number
\end{verbatim}

Normalising the intensity to a value in the header:

\begin{verbatim}
img = fabio.open('exampleimage0001.edf')
print(img.header)
{'ByteOrder': 'LowByteFirst',
 'DATE (scan begin)': 'Mon Jun 28 21:22:16 2010',
 'ESRFCurrent': '198.099',
...
}
# Normalise to beam current and save data
srcur = float(img.header['ESRFCurrent'])
img.data *= 200.0/srcur
img.write('normed_0001.edf')
\end{verbatim}

Interactive viewing with matplotlib:

\begin{verbatim}
import pylab           # pylab is part of matplotlib
pylab.imshow(img.data) # display as an image
pylab.show()           # show GUI window
\end{verbatim}


\section{Future and perspectives}

Hierarchical data format version 5 \cite{hdf5} is a data format which is
becoming popular in the field of synchrotron X-ray data storage. 
For now, mainly processed or curated data are stored in this format but 
new detectors are rumoured to provide native output in HDF5.
% If there is no citation then this is not really something for us to report?
% (i.e. the detector Eiger from Dectris is planeed to do so). 
Since the internal structure of HDF5 is very versatile, FabIO will need to expose 
specifically detector images (data and headers) when the internal structure 
of such files becomes known. 
H5Py \cite{h5py}, which provides a good HDF5 binding for Python, is likely to
make it easy to interface FabIO to such files.

In the near future FabIO will be upgraded to work with Python3 (a new version of 
Python); this change of version will affect some internals FabIO as string and 
file handling have been altered.
This change is already ongoing as many parts of native code in C have already
been translated into Cython \cite{cython} to smooth the transition, since 
Cython generates code compatible with Python3. 
This also makes it easier to retain backwards compatibility with the earlier
python versions. % hint hint :-)

%Another issue is the absence of an official PIL port to
%Python3, so PIL has already been made an optional dependency and its features could be
%reimplemented using other libraries. 
%
% Readers of J.Appl.Cryst probably dont care about so much detail.
% The PIL site says it will be released "later" and private ports are already
% available.
% scipy.ndimage does filtering, fabian will have to cross that bridge
% when it goes to python3.
%

\subsection{Conclusion}

FabIO gives an easy way to read and write 2D images when using the
Python computer language.
It was originally developed for X-ray diffraction but now gives
an easy way for scientists to access and manipulate
their data from a wide range of 2D X-ray detectors.
We welcome contributions to further improve the code and hope to add
further file formats in the future as well as port the existing code base 
to the emerging Python3.


\subsection{acknowledgement}
We acknowledge Andy G\"otz and Kenneth Evans for extensive testing when including
the FabIO reader in the Fable ImageViewer.
We also thank V. Armando Sol\'e for assistance with his TiffIO reader and
Carsten Gundlach for implementation of FabIO at the beamlines i711 and i811, 
MAX IV and providing bug reports.
We finally acknowledge our colleagues who have reported bugs and helped to
improve FabIO.
Financial support was granted by the EU 6th Framework NEST/ADVENTURE project
TotalCryst.




\bibliographystyle{iucr}
\bibliography{biblio}


\appendix
\section{Various detector format supported by FabIO.}
% put in appendix it can be full width
\onecolumn
\begin{table}[h]

\caption{\label{format}List of file formats that FabIO can read and write}
\vspace{1mm}
\begin{center}
\begin{tabular}{llccc}
Python Module   & Detector		& Typical extension & Multi-image	& Write\\% & Notes\\
\hline % alphabetical order - all formats are equal :-)
adsc	   &   ADSC Quantum		&	.img	&	No	&	Yes		\\%Check\\
bruker		&   Bruker formats		&	.sfrm	&	No	&	Yes		\\%TODO Complete\\
DM3			&						&	.dm3	&	?	&	?		\\%?\\
edf		    &   ESRF data format	&	.edf	&	Yes	&	Yes		\\%Several bit formats\\
EDNA-XML \cite{edna}	& &	.xml	&	No		&	No	 \\%Internaly used in EDNA\cite{edna}\\
cbf		    &   CIF Binary Files	&	.cbf	&	No?	& 	Yes		\\%Used also by Pilatus \\
kcd	    	&   Nonius 	KappaCCD	&	.kccd	&	No 	&	No		\\%Multiples frames are merged are reading. now bruker\\
fit2dmask \cite{fit2d} 	&			&   .msk    &   No  &   Yes  \\
fit2dspreadsheet \cite{fit2d}	&  	&  .spr    &   No  &   Yes    \\
GE		    &   General Electric	&	-		&	Yes	&	No?		\\%massivly multi-frame\\
HiPiC       & Hamamatsu CCDs 		&	.tif	&	No	&	No?	 	\\%Tiff based format\\
marccd		&   MarCCD/Mar165		&	.mccd	&	No	&	No?		\\%Tiff based format\\
mar345		&   Mar345 image plate	&	.mar3450		&	No	&	Yes		\\%Compressed format\\
OXD		    &   Oxford Diffraction 	&	.img	&	No	&	Yes		\\%now Agilent\\
pilatus	    & Dectris Pilatus Tiff	&	.tif	&	No?	&	No?		\\%Tiff based  format\\
PNM			&	Portable aNy Map	& .pnm	&	No	&	?		\\% pnm is a unix image format
TIFF		&	Tagged Image File Format	&	.tif	&	No	&	?		\\%can be compressed or not\\
\end{tabular}
\end{center}
\end{table}

\end{document}
